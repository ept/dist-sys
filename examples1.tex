\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage{url}
\usepackage{hyperref}

% Run pdflatex with option -shell-escape to enable syntax highlighting
\usepackage{minted}
\usepackage{xcolor}
\definecolor{LightGray}{gray}{0.95}
\setminted{bgcolor=LightGray}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.7em}

\begin{document}
\title{Distributed Systems Examples Class 1}
\author{Martin Kleppmann}
\date{}
\maketitle

\section{Time in Distributed Systems}

Load \url{https://www.cst.cam.ac.uk} in Firefox, click padlock, view certificate expiry date.
Set system clock to a date after the expiry, then click shift+reload, and we should see an expired certificate error.
(This seems to be more reliably reproducible in Firefox than in Chrome.)

\texttt{dig www.cst.cam.ac.uk} --- see how the TTL counts down. To make the output \href{https://jvns.ca/blog/2021/12/04/how-to-use-dig/}{less verbose}:
\begin{minted}{bash}
dig www.cst.cam.ac.uk +noall +answer
\end{minted}
Note: does not count down when on Eduroam!

\section{RPC Demo}

\texttt{Procfile}
\begin{minted}{bash}
# Fix number of workers to 1 since we're keeping state in global variables
web: gunicorn --workers 1 --threads 1 app:app
\end{minted}

\texttt{.gitignore}
\begin{minted}{bash}
/__pycache__/
/venv/
\end{minted}

\texttt{app.py} (minimal)
\begin{minted}{python}
from flask import Flask

app = Flask(__name__)

@app.route("/")
def index():
    return "<p>Hello world!</p>"
\end{minted}

Run the following in that directory:

\begin{minted}{bash}
python3 -m venv venv
. venv/bin/activate
pip install Flask
export FLASK_ENV=development # enables automatic code reloading
flask run

# For Heroku deployment
pip install gunicorn
pip freeze > requirements.txt
git init
git add app.py Procfile requirements.txt .gitignore
git commit -m 'Flask environment setup'
git branch -m main
heroku create
git push heroku main
\end{minted}

\texttt{app.py} (to do list)
\begin{minted}{python}
from flask import Flask, request, render_template, jsonify

app = Flask(__name__)

tasks = []
next_task_id = 1

@app.route("/tasks")
def list_tasks():
    return jsonify(tasks)

@app.route("/tasks", methods=["POST"])
def add_task():
    global tasks, next_task_id
    task = {"id": next_task_id, "text": request.form["text"], "done": False}
    tasks.append(task)
    next_task_id += 1
    return task

@app.route("/tasks/<int:task_id>")
def get_task(task_id):
    return next(task for task in tasks if task["id"] == task_id)

@app.route("/tasks/<int:task_id>", methods=["POST"])
def update_task(task_id):
    task = next(task for task in tasks if task["id"] == task_id)
    done = request.form["done"] == "true"
    task["done"] = done
    return task

@app.route("/")
def index():
    return render_template("index.html")

@app.errorhandler(StopIteration)
def handle_exception(e):
    return {"message": "Item does not exist"}, 404
\end{minted}

\texttt{templates/index.html}
\begin{minted}{html}
<!DOCTYPE html>
<h1>My task list</h1>
<ul id="tasks">
</ul>

<form id="new_task">
<p><input type="text" id="text"> <button type="submit">Add task</button></p>
</form>

<script>
loadTasks()

async function loadTasks() {
  const response = await (await fetch('/tasks')).json()
  document.getElementById('tasks').innerHTML = ''
  for (let task of response) renderTask(task)
}

document.getElementById('new_task').addEventListener('submit', async (event) => {
  event.preventDefault()
  const input = document.getElementById('text')
  const request = new URLSearchParams({text: input.value})
  const response = await fetch('/tasks', {method: 'POST', body: request})
  renderTask(await response.json())
  input.value = ''
})

function renderTask(task) {
  const list = document.getElementById('tasks')
  list.insertAdjacentHTML('beforeend',
    `<li><input type="checkbox" id="task${task.id}"> ` +
    `<label for="task${task.id}"></label></li>`)
  list.lastElementChild.querySelector('label').innerText = task.text

  const checkbox = list.lastElementChild.querySelector('input')
  checkbox.checked = task.done
  checkbox.addEventListener('click', (event) => {
    setTaskDone(task.id, event.target.checked)
  })
}

async function setTaskDone(taskId, done) {
  const request = new URLSearchParams({done})
  const response = await fetch(`/tasks/${taskId}`, {method: 'POST', body: request})
  console.log(await response.json())
}
</script>
\end{minted}

To test from the command line:
\begin{minted}{bash}
curl -i -F text=hello http://127.0.0.1:5000/tasks
curl -i http://127.0.0.1:5000/tasks
curl -i http://127.0.0.1:5000/tasks/1
curl -i -F done=true http://127.0.0.1:5000/tasks/1
\end{minted}

Use web browser to try requesting some tasks that don't exist, and see the error message generated by Flask.

Turn off WiFi, or use Network Link Conditioner to drop all packets, and see what exceptions are raised in the JavaScript console.

Have you ever tried calling a Python function from JavaScript code? It's a complete nightmare! RPC is probably the easiest way of doing this.

\section{Proof of Byzantine Generals Problem}

Based on \href{https://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf}{Dwork et al., Theorem 4.4}.

In a partially synchronous system with $n$ nodes, of which $f$ are Byzantine-faulty, there is no algorithm that ensures consensus if $n \le 3f$ while also tolerating $f$ crashed nodes.
To prove that there is no algorithm, we assume to the contrary that there exists an algorithm for $3 \le n \le 3f$, and derive a contradiction.
We divide the $n$ nodes into three disjoint subsets $p$, $q$, and $r$, each with at least $1$ and at most $f$ nodes.

Scenario A: all nodes in $p$ and $q$ want to attack, all nodes in $r$ are crashed, and all messages between nodes in $p \cup q$ are delivered with low latency.
Because the algorithm tolerates up to $f$ crashes, it must terminate within some finite time $T_A$, and all nodes in $p$ and $q$ must decide to attack.

Scenario B: all nodes in $q$ and $r$ want to retreat, all nodes in $p$ are crashed, and all messages between nodes in $q \cup r$ are delivered with low latency.
Because the algorithm tolerates up to $f$ crashes, it must terminate within some finite time $T_B$, and all nodes in $q$ and $r$ must decide to retreat.

Scenario C: all nodes in $p$ want to attack, all nodes in $r$ want to retreat, and all nodes in $q$ are Byzantine-faulty.
The nodes in $q$ behave exactly the same way as in scenario A when communicating with nodes in $p$, and they behave exactly the same as in scenario B when communicating with nodes in $q$.
Moreover, all messages between nodes in $p \cup q$ are delivered with the same latency as in scenario A, and all messages between nodes in $q \cup r$ are delivered with the same latency as in scenario B.
However, all messages from nodes in $p$ to nodes in $r$, or from nodes in $r$ to nodes in $p$, take at least $\max(T_A, T_B)$ time before they are received.
Since the nodes in $p$ act exactly like they do in scenario A, they must decide to attack; and since the nodes in $r$ act exactly like they do in scenario B, they must decide to retreat.
This contradicts the requirement that the algorithm ensures consensus.

\end{document}
